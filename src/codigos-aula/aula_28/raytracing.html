<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <title>WebGL Ray Tracing Espelhado</title>
  <style>
    body, html {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Vertex shader (simples, tela cheia)
const vsSource = `
attribute vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

// Fragment shader com ray tracing
const fsSource = `
precision highp float;

uniform vec2 u_resolution;
uniform float u_time;

// ---------- Ray / geometria ----------

bool intersectSphere(vec3 ro, vec3 rd, vec3 center, float radius, out float t) {
  vec3 oc = ro - center;
  float b = dot(oc, rd);
  float c = dot(oc, oc) - radius * radius;
  float h = b*b - c;
  if (h < 0.0) return false;
  h = sqrt(h);
  t = -b - h;
  if (t < 0.0) t = -b + h;
  return t > 0.0;
}

bool intersectPlane(vec3 ro, vec3 rd, out float t) {
  if (abs(rd.y) < 0.0001) return false;
  t = (-1.0 - ro.y) / rd.y;
  return t > 0.0;
}

// ---------- Materiais ----------

vec3 checkerboard(vec3 p) {
  float c = mod(floor(p.x) + floor(p.z), 2.0);
  return mix(vec3(0.05), vec3(0.9), c);
}

vec3 sky(vec3 rd) {
  return mix(
    vec3(0.8, 0.9, 1.0),
    vec3(0.2, 0.3, 0.6),
    rd.y * 0.5 + 0.5
  );
}

// ---------- Cena ----------

vec3 trace(vec3 ro, vec3 rd) {
  float tSphere, tPlane;

  bool hitSphere = intersectSphere(ro, rd, vec3(0.0, 0.0, 0.0), 1.0, tSphere);
  bool hitPlane  = intersectPlane(ro, rd, tPlane);

  // ---------- Esfera ----------
  if (hitSphere && (!hitPlane || tSphere < tPlane)) {

    vec3 hit = ro + rd * tSphere;
    vec3 normal = normalize(hit);

    // raio refletido
    vec3 reflDir = reflect(rd, normal);
    vec3 reflOri = hit + normal * 0.001; // evita acne

    // testa reflexão contra o piso
    float tPlaneRefl;
    if (intersectPlane(reflOri, reflDir, tPlaneRefl)) {
      vec3 reflHit = reflOri + reflDir * tPlaneRefl;
      return checkerboard(reflHit);
    }

    // senão, reflete o céu
    return sky(reflDir);
  }

  // ---------- Piso ----------
  if (hitPlane) {
    vec3 hit = ro + rd * tPlane;
    return checkerboard(hit);
  }

  // ---------- Céu ----------
  return sky(rd);
}


void main() {
  vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;

  vec3 ro = vec3(0.0, 0.5, 4.0);
  vec3 rd = normalize(vec3(uv, -1.5));

  vec3 color = trace(ro, rd);

  // leve correção gamma
  color = pow(color, vec3(0.4545));

  gl_FragColor = vec4(color, 1.0);
}
`;

// Compilação dos shaders
function compileShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}

const vs = compileShader(gl.VERTEX_SHADER, vsSource);
const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
gl.useProgram(program);

// Quad tela cheia
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,
   1, -1,
  -1,  1,
   1,  1
]), gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const resLoc = gl.getUniformLocation(program, "u_resolution");
const timeLoc = gl.getUniformLocation(program, "u_time");

function render(time) {
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.uniform2f(resLoc, canvas.width, canvas.height);
  gl.uniform1f(timeLoc, time * 0.001);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}

requestAnimationFrame(render);
</script>
</body>
</html>